<!-- # TypeScript 使用 type 模拟 interface 的功能 -->
好几次在群里碰到有群友问：“type 和 interface 有什么区别吗？”。
我就会打趣的说到：“老板说有 interface 你就用 type，老板说用 type 你就用 interface。”。
interface 和 type 两者的功能确实有很多地方重叠。也有一些差异，这篇文章将用 type 去模拟 interface 的一些功能。后面会提到 interface 和 type 的差异。

## 两者差异 1：interface 的声明合并
先说两者的差异。最大的差别是 interface 有 **[声明合并](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)** 的功能。这个功能非常将强大给力，可以给第三方包的 interface 做扩展，添加一些属性或方法。如果一个包使用了 type 那么将不能为这个类型做扩展了，所以 **开发一个包的时候 export 出来的类型尽量用 interface**。

**不管开发者懂不懂这两者的差别，都应该尽量使用 interface**。interface 更像一种规范，大部分包都会用 interface 导出类型，像 `lib.dom.d.ts` 里面声明的大部分类型都是。type 更像一个类型别名（如：`type X = 1 | 2`），而且 type 有它独特的用处，type 用来参与类型运算（如：`type X<T> = { [K in keyof T]: () => T[K] }`），这些个都是 interface 做不到的。到了某个阶段自然会明白，用 interface 写不了的时候就知道要用 type 来写了。

下面的示例代码，为了方便区分两者的命名，type 使用 `T` 开头，interface 用 `I` 开头（不建议在实际代码中这么做，`I` 开头是一些编程语言的习惯，在 TS 中本人是不建议这么做）。

## 两者差异 2：type 表达更精确的类型

### 类型别名
这是 type 最常见的功能了，不过下面的代码示例是一些技巧，能够用好类型推导和类型运算，就能感觉到 TS 的类型系统的强大，[TS Playground](https://www.typescriptlang.org/play?#code/LAKA9GAEicFodsaQewEYCsCMlAhboPO1CiaYT+1BDGMHbgwNeVBg7U0gGsBTAT0kG8fQaPVQAXegB1sgHlUaANINIAXhoMEAM0iceMxINARIagHoB+UAGMEAOwDO7JenGQA3pACGALkhoANJCT2ATM532AzJAC+oCpQ8ryYgA8agHBmgPRmgPfKgKdygBTqRIA8CpiAskqARumYQTDw7ACuXBiYyWSA6toZgPOJrBzcvACy9CL0GBIhigVFANr6+QC2SLQATgC6ORraIHpGJp2tkF0ARADiAKIAKovOiwAKfADKm9sAIqsAMhuriyM2hpDTxoEgoACW+uzD0tY6vACSAIJuSygNTSfRoAAUdkgvQGw2crkgxiGbwA5p5NPZjtYPgBKeywwZDUABcBQMiQAFuAB0YIwgE7TQCrNphAEPKgAdTGogEKQABi4P+Q1RdwkO2sQ2sfVoHyGhgAPFSlnTrgA+caQLRAA)。
``` ts
// 根据 obj1 的实际对象获取它的 key 类型
type Obj1Key = keyof typeof obj1
//   ^?
const obj1 = { a: 1, b: 2, c: 3 }

// type 的声明是可以在对象值的前面的
// 根据 tup1 的值获取字面量类型
type MyKey1 = typeof tup1[number]
//   ^?
const tup1 = ["GET", "POST", "DELETE"] as const


interface IA2 {
  fn1(a: number, b: string, c?: Date): number
}
// 获取 IA2.fn1 方法的参数类型
type Fn1Args = Parameters<IA2["fn1"]>
//   ^?
```
### 联合类型（Union）和字面量类型

常见的字面量写法，[TS Playground](https://www.typescriptlang.org/play?#code/LAKALgngDgpgBAOQK4FsCMcC8c0AY4A+cATPkQMy6iiSxwCCAxmAJYD2AdhtgEQDmMMD0JweAQwAmE4UR4SYAG0Ewe1cNHgA1MQqQxucDqgBGMAE4iAzmDMsOfEQDMdl+ESQd5juzAmggA)：
```ts
type Num1 = 10 | 20 | 30

type Action1 = "get" | "add" | "delete"

type Value1 = number | string | false | undefined
```

Union 类型约束比 interface 更强，[TS Playground](https://www.typescriptlang.org/play?#code/LAKAlgdgLgpgTgMwIYGMYAICCEwFskA26A3ukjvgQFzoDOUckA5ugL6iSyKoYAiA9ixgAPWBAAmtLBUIl04wTXqMILduGjxkadAGEkUdCLGTpeWaRQGlDZmw6buO3gFcUAayOiYEqdnNEpOJu7jYqaqAA9JHogKdygFBygN4+gNHqgPRmgDTegJBygJ2mgKDKgAvGgNnygCFugDD-gIhGgDdygE+6gPN+gLBygL8BgHfygJymoFEAVJ3o5cWABdqAlk7onZGgUACeAA4YALITAAowhgC86AIsAD56BlExgADpgIGRgGV+gPrmfUOAV8qAkObrguiAMSo7UKWAm-GAVHLZgKs2l4AgmoBgLq9ACRygFnPFJ7dCcLQ8dCAO7dALJKTUAffGABiVXiCzqVLo0zoAuOTMlFKEMAaEaAUADABTqgAX4wAyEYA300A2UaAL8UUvVAPSmgEBjUAIFwQFBQMD8CDoWD0AAUuEWyxo8yWUAAlCRQOhIQh0KKAEQKJjqyFCiWyhXEJXK9D65YAOi16DW6olG3VxuV0XQAD0APzG1hGAi0DBGkAm02SqDmqyrdC2ib6KAOgMm53uz2gVhAA)：
```ts
interface Animal { animal: string }
interface Dog extends Animal { dog: string }
interface Cat extends Animal { cat: string }
interface Duck extends Animal { duck: string }
// 以上类型是第三方包提供的，我们已经不能修改

/** 我的宠物 */
type MyPet = Dog | Cat
// 需要约束我的宠物只有 Dog 和 Cat，这个方法只处理这两种类型
// interface 目前不能达到这种约束，只能约束为 Animal，
// 或者在运行时抛出类型不支持
function test(myPet: MyPet) {
  if ("dog" in myPet) {
    myPet.dog = "myDog"
    // ^?
  } else {
    myPet.cat = "myCat"
    // ^?
  }
}
```

### 元组类型
来看一下 TS 对元组的支持，[TS Playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAKgrmAjFAvFA2gOzgWwEYQBOANFNvkQLoCwAUKJLAgEyobkElQDOwhAlpgDmpAHTiORdJRr1w0eGADMbdONGTC00rwHDZDBQgAsqzTr6ChAflKbrB+UzABWVQEMAXGVydSeb10rUgBja28AEXdgCEogA)：
```ts
type Tup1 = [number, number]
type Tup2 = [number, string, ...number[]]
type Tup3 = [...number[], string]
type Tup4 = [number, string?, number?]
type Tup5 = [a: number, b: string, c?: Date]
```

### 类型运算
type 可以做一些条件运算，返回不同的类型，或者生成另一个类型。[TS Playground](https://www.typescriptlang.org/play?#code/PTAEk4LQ7Y1AVVBC3QsHKBgVQ3j6Gj1QMP+BX4we2ovgwFgAoAFwE8AHAU1gEEAeGAPlAF5ZQaAPMmgHYATAM6gyAJwCudAPygBUgLYAjGhNAAuUCMkBLAQHNSlWgwCMHBo0ky2IBcrUTSD0KAB6sk9Tox6AExW-owAZgCGADYiNPZguhIGxiRunt4krmCAUUawAPIqAFaggAJGgJDmgHo6gOQGgDbxgEbGgAhGgL+KgA6mPmYwAELM+QVsnADepO4A2gDSoAagANY0FAD2oXmFALraABQAlBxsMD1jy6QAvm1+HZacnYz9oOHaiqrqADSgKtoJSaCHLJnuaaRAA)：
``` ts
// 根据 T 的不同类型，返回不同的类型
type TA<T> = T extends true ? number : string
type TA1 = TA<true> // number
//   ^?
type TA2 = TA<false> // string
//   ^?

// 把 TObj 所有属性转换成函数
type TB<TObj> = {
  [K in keyof TObj]: () => TObj[K]
}
type TB1 = TB<{ a: number, b: string }>
//   ^?
```

## 两者差异 3：type 和 interface 的索引类型
---

type 和 interface 都可以声明索引类型，interface 只能声明一个，并且之后的继承都要满足这个约束，type 则不同。[TS Playground](https://www.typescriptlang.org/play?#code/LAKAlgdgLgpgTgMwIYGMYAICSBBdBvUddJALnQGco5IBzQ9AIzIgFcBbB+egem-RTIARJLHS90gUqNAmKmAYf8APGoDgzQCFugPR1A5AaBR-UDeGYEO7QM2xgIl9AqPqBvH0DR6ksBlfoH1zegG0A1jACeZStQg0Aum6q10AD7orBxcIETidiHM7JxwPsGxYQC+oKCQsIioGJgAQugwAB6wEAAm5Fi4BOHopUIiGOLSoKkgoFDOAA4YACq4ALz49KQUfp72Tq6jHt6+My3oAGRDNeKA98qAp3JL6IBuioBrcurm9EyJoXD0AujCsAvL1UQRfICb8YBUcoD6coD0ZoCCioAd0Ur0RDsAGkXOhIOgAEQICAARghgUh0IATBCEgAKACU6H6AD5TnF6K00iAECwICgoGAAPYQdCwShoqAjPpY+78GmUfjYulIAB0KB4fAeAD0APwXDlQdDQmHcpl2KGw1GCh7oMUSiCcqlQAAW8DlSAV2r1cGVqyFRHVIGSQA)：
```ts
interface IA {
  a: string
  b: number
  // c: Date // 报错，声明的属性必须满足索引类型的约束
  [key: string]: string | number
  // [num: number]: number
}

interface IB extends IA {
  d: Date // 报错
}

type TA = {
  a: string
  [key: string]: string
} & {
  // 可以 & 其他属性类型
  b: number
  c: Date
} & {
    // 这个也是允许的
    [Key in "fn1" | "fn2"]: () => number
  }


function test(ta: TA) {
  const c = ta.c
  //    ^?
  const fn1 = ta["fn1"]
  //    ^?
  const other = ta["other"]
  //    ^?
}
```
---

interface 还有一个影响比较大的约束，它的**索引类型也会约束到声明合并**。比如本包使用 `interface IA { [key: string]: string }`，那么第三方包声明合并的时候只能声明合并是 `string` 类型的属性，要不然本包代码里的类型约束为 `string` 属性那不就失效了吗？会引起类型安全问题。

[TS Playground](https://www.typescriptlang.org/play?#code/LAKA9GAEg05ooMqA8ag4M0CFugAOUFRykCWA7ALgKYBOAZgIYDGBoBAHgA4D2Re2+x5VkAkgIKQBvSAG0A1gQCeALkgBnPEVwBzALoz5inEsgBfGg2asSAVxwU8WRjkgkcvABRYyMvgBpI46R8mMSPXgCUgqCQkBRW8pAAbmQANsYEkAC82GRikiohkBChoQB6APxZMfEEAHR4jACq9PTEAMJksgT2QTmAn9pyCsqQgNvxgDIRkJU1dUSNzaB64FCAp3KAUHKA9GZwSIAMSoAgmsiAx3KAgB6ge9OQM4DQcguANN6AkHKAnaawgM8GgFxy-pCA37aABUpIgBAqgG56gDD-r4B6OoByA30TBYbEIpEoiT4wRAoQAJjIACJkQjZKCAUqNAJipC3ayG+gG8fQDR6oBYOUAkdqAC0VJkA)：
``` ts
// 本包声明的一个 interface
export interface IA { [key: string]: string }
export function fnA(ia: IA, key: keyof IA) {
  const value = ia[key]
  //    ^?
  value.toUpperCase() // 对 string 进行 toUpperCase
}
// 以上是本包声明到处的代码


// 以下是第三方包想为 IA 添加声明合并，添加属性
export interface IA {
  d: Date // 报错是对的，类型不安全
}
```
---

再来看一个泛型问题，[TS Playground](https://www.typescriptlang.org/play?#code/LAKALgngDgpgBAZTAJwEowMYHtkBM4C8cA3nANoDWAXHAM4oCWAdgOYC6N9yzLcAvqABmAVyYYwDLEziCmARgA8AFTgwAHmBhNctRCnTY8APgAUWAEYArGkoCUJfqFDNNyQQEMM8AJIBBEqBwcO6cjKyBcOah3OEgAiBCouKS0pr0JgwhcH72xBGychnuthEA9KVwvsgswgC2WmBwWIJwkLBwAOR+HXAMukxYje60tAwsTO7mADbwYFhwUO7I7vWuTS1t8B1IaJg4uB0AdGUV3trqdGMTYMLI8II4rdBbXDw9fXC1faOsvanPnW6xziQA)：
``` ts
type StrRecord = { [k: string]: string }
function fn1<T extends StrRecord>(obj: T) { }

interface IA {
  a: string
  b: string
  // IA 的所有属性都是 string 类型，看起来满足了 StrRecord 的约束
  // [k: string]: string
}

function test(ia: IA) {
  fn1(ia) // 报错
  // Argument of type 'IA' is not assignable to parameter of type 'StrRecord'.
  // Index signature for type 'string' is missing in type 'IA'.
}
```
---

仔细看着报错原因也大概知道了，需要添加索引类型的声明。这个报错原因和刚刚提到的声明合并有关系，因为第三方包可能会为 `IA` 添加其他类型的声明合并，导致 `IA` 的属性不一定都是 `string` 类型，所以不能满足泛型约束。但是如果使用 type 来声明这个类型就可以规避这个问题。[TS Playground](https://www.typescriptlang.org/play?#code/LAKALgngDgpgBAZTAJwEowMYHtkBM4C8cA3nANoDWAXHAM4oCWAdgOYC6N9yzLcAvqABmAVyYYwDLEziCmARgA8AFTgwAHmBhNctRCnTY8APgAUWAEYArGkoCUJfqFCRYcJQEFCJUHDgBDTkZWHzhzQO5gkAEQIVFxSWlNehMwALd3e2IQ2TkUv1tQPiA)：
``` ts
type StrRecord = { [k: string]: string }
function fn1<T extends StrRecord>(obj: T) { }

type TA = {
  a: string
  b: string
}

function test(ta: TA) {
  fn1(ta)
}
```
## type 模拟 interace 的功能
---
type 和 interface 虽然有些差异，但是 type 是可以模拟 interface 的大部分功能的。（**注意：仅作为示例，该用 interface 还是要用 interface**）

## type 模拟 interface 的字段属性
---

<table>
<tr>
  <td width="50%">

```ts
interface IData {
  a: number
  readonly b?: string
  fn1(): string
  fn2: () => string
}
type TData = {
  a: number
  readonly b?: string
  fn1(): string
  fn2: () => string
}
```
问个无关的问题，`IData` 中 `fn1` 和 `fn2` 两者的声明有区别吗？
  </td>
  <td>

用起来没什么区别，约束都一样。但是写起来不一样，有些情况下有的写的更舒服。
```ts
interface IData {
  // 1、这个方便写函数重载
  fn1(): string
  fn1(x: number): number

  // 2、这个方便写可选属性
  fn2?: () => string
}
```
  </td>
</tr>
</table>

## type 模拟 interface 函数对象
---
<table>
<tr>
  <td width="50%">

[TS Playground](https://www.typescriptlang.org/play?#code/LAKAlgdgLgpgTgMwIYGMYAICSAxC6Deo66AFAJQBc6EArgLYBG86APugM5RyQDmRpSKsgA27GJWr0mcfiUHouNcVU7cIfEMTgwkAEwD2EYQE90CCAAU4+gA5UG+-cJ0RQAX1BRjNjABVc6AC8-ABkpORBAHySjMxsqrxkoeHyImJkUTHSSZroYSRyVIrimQnqOcRh+OjaeoYmZpbWdugOTi7oHiCgCDQQKFBghgownCRQuFT+EAA06GCTWLgZhLkohpwKAIxBCrjk-AD0h8TEAHoA-PzrEJtQAEy7ExAkaeJHJ6eX1xtQCgDMT32xQq6GOp3Q3zWvwUABYgRAAHTmKy2D4QqE-W5-MA7QLzfag8FfK7Q7HzR74hYvN5Ez7nUnEG6bMCAqnAuBKOkYxnoZk4+HspEo5roknuIA)
```ts
interface IFn {
  (): number | string
  (a: false): number
  (a: true): string
  readonly fnProp: boolean
}
type TFn =
  & (() => number | string)
  & ((a: false) => number)
  & ((a: true) => string)
  & { readonly fnProp: boolean }

function test(tFn: TFn, iFn: IFn) {
  const t1 = tFn()
  //    ^?
  const t2 = tFn(false)
  //    ^?
  const t3 = tFn(true)
  //    ^?
  const t4 = tFn.fnProp
  //    ^?

  const i1 = iFn()
  //    ^?
  const i2 = iFn(false)
  //    ^?
  const i3 = iFn(true)
  //    ^?
  const i4 = iFn.fnProp
  //    ^?
}
```

  </td>
  <td>

注意 interface 是可以给第三方使用者添加函数重载的声明的，type 无法模拟的。
[TS Playground](https://www.typescriptlang.org/play?#code/LAKAlgdgLgpgTgMwIYGMYAICSAxC6Deo66AFAJQBc6EArgLYBG86APugM5RyQDmRpSKsgA27GJWr0mcfiUHouNcVU7cIfEMTgwkAEwD2EYQE90CCAAU4+gA5UG+-cJ0RQAX1CgA9F-SAab0BIOUBO00B-eUAKV0BQAMBv20ACpUAHjUA4M0AIFUA3PVBIWERUDBw8Qk0BISRRGAAadAYqWkZ4CQcnF3dPEAQaCBQoMEMFGE4SMFwqXLICfhRDTnQwAEZ0AF4p3HJ+H2JiAD0AfjGJqCmAJnnFiBIRMTIV3zWtnYhJsABmI4GTxXFLtfQbgvG7vbAACzPJZnMrofYABn2kIAnNMABwXAqra7bEBuIA)
```ts
interface IFn {
  (): number | string
  (a: false): number
  (a: true): string
  readonly fnProp: boolean
}

// 第三方使用者添加声明合并
interface IFn {
  (a: false, b: number): boolean
}

function test(iFn: IFn) {
  const i1 = iFn()
  //    ^?
  const i2 = iFn(false)
  //    ^?
  const i3 = iFn(true)
  //    ^?
  const i4 = iFn(false, 20220918)
  //    ^?
}
```

  </td>
</tr>
</table>


## type 模拟 interface 继承
---
<table>
<tr>
  <td width="50%">

```ts
interface IA {
  a: number
  fnA(): number
}
interface IB {
  fnB(): number
}
interface IC extends IA, IB {
  fnC(): number
}

type TA = {
  a: number
  fnA(): number
}
type TB = {
  fnB(): number
}
type TC = {
  fnC(): number
} & TA & TB

function test(ic: IC, tc: TC) {
  const res1 = ic.a + ic.fnB()
  const res2 = tc.a + tc.fnB()
}
```
[TS Playground](https://www.typescriptlang.org/play?#code/LAKAlgdgLgpgTgMwIYGMYAICSBBdBvUddJALnQgFcBbAI3kPQQmwAoBKMy2+kAX1EixEqDJgBC+BkzHtO1OnFD9w0eMjRYAwuhgAPWBAAmAZyzYANFgkEQRJptnl5PZaCgBPAA4YAKrgC8krbEctyKwUysHE5hSm5evhKBNnYQMtFcCnEgHt7oPtrJUhAOGc7hvOgAZPm4NT5ioKAIFBAoUGAA9hDosMZQLGAoZJiallDD+ZpsQUQo3f3ocDDGAIzogUMAdEjoANTo29LsDPMQi8vGAEwbvSg7+3dbx2xKQA)。这都是一些正常的写法，接口之间没有相同的属性成员。如果有相同的属性成员，interface 会根据继承的接口做类型约束检查，某些情况下直接报错。
  </td>
  <td>

```ts
interface IA {
  a: number
  b: string
  fnA(): number
  fnB(): string
}

interface IA1 extends IA {
  a: 1 | 2 // 类型安全的
  b: string | number // 不符合类型安全的
}

interface IA2 extends IA {
  fnA(): 1 | 2// 类型安全的
  fnB(): number | string// 不符合类型安全的
}
```
[TS Playground](https://www.typescriptlang.org/play?#code/LAKAlgdgLgpgTgMwIYGMYAICSBBdBvUddJALnQgFcBbAI3kPRrIGco5IBzBhCbACgCUZSrXogiPAEKCWbTqAC+oUJFiJUGHAEZ0MAB6wIAE2ZZcBccTI6APugBM6APRP0gbx9A0eqBI7UAWioBC3BiZ0VnYIDnQ7ETo4Z1dAWDlAMm9ACBVPXwCQJRAVaHhkNDNHfUMTM3xuXhl0WwcXd29-cukhcmpoiOC5MNrElPr0hSA)。这些约束都是对的，是符合类型安全的。可以这么说，接口继承的成员必须比基类型更精确（类型更窄），`IA1.b` 的做法是把 `IA.b` 类型变得更宽了，这是类型不安全的。假设把 `IA1` 赋值给 `IA`，那么 `IA.b` 可能得到就是 `number` 类型。
下面是函数参数类型逆变（概念不好解释在此略过），是允许的，也是正确的，[TS Playground](https://www.typescriptlang.org/play?#code/LAKAlgdgLgpgTgMwIYGMYAICSBBdBvUddBCbACgA8AudCAVwFsAjeAShoDcB7MAE0OIQAQpRoBnKHEgBzdum59QAX1AB6VekC-ioAdTQEPK2wN4+gaPVAYAmAN5VCRYiVBhwBGdDAqwIvMVlwEQRdekBc-oCIOvqAMP+A+nKA9GbGgJHagBaKgCFuAiTkcgr8IAJ++sZmgL3a4VFGcYk+giLU6BJSENLoAD60jCxwqTzpSkA)。
```ts
interface IA {
  fnA(x: number): void
  fnB(x: string): void
}
// 函数参数类型逆变
interface IA1 extends IA {
  // 缺少参数，也是类型安全的
  fnA(): void

  // 参数类型变宽，也是类型安全的
  fnB(x: string | number): void
}
```

  </td>
</tr>
</table>

----
<table>
<tr>
  <td width="50%">

type 对这类相同的属性成员会进行 & 处理（取交集），而不会像 interface 那样报错。[TS Playground](https://www.typescriptlang.org/play?#code/LAKALgngDgpgBAFQIJwLxwN6jnAhgLjgDsBXAWwCMYAnbOCwgZzGoEsiBzUAX1FEliIkARjRC4AMkx0CcUQB84AJjoNi5KrRC8QoAGYkiAYzCsA9kThgYzABRhcwwsmEBKTHDpGLzONRui6FaOAHS4cAD0EXJwiiogOFE4OAB6APxePmB+NkpiwcIhFJHRRDQAbjR0ScnpPEA)。
```ts
type TA = {
  a: number
  b: string
}

type TA1 = TA & {
  a: 1 | 2
  b: number
}

function test(ta1: TA1) {
  const res1 =  ta1.a // 1 | 2
  //    ^?
  const res2 =  ta1.b // nerver
  //    ^?
}

```

对于函数 & 是重载的意思，interface 继承是不允许的，会直接报错的。[TS Playground](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgJIEFkG8CwAoZZGEARgAo4AuZEAVwFsAjaASmoGcwpQBzfAX3yhIsRCgwlkEAB6QQAE3ZpMuAkVIVqjAPbaANhDgg2yHfsMhkAeivJA3j6Bo9UBNioECvAUA)。

``` ts
interface IA {
  fn1(a: number): string
}
interface IA1 extends IA {
  fn1(a: boolean): boolean // 类型冲突
}
```

  </td>
  <td width="50%">

``` ts
type TA1 = {
  fnA(a: 1 | 2): 10
  fnB(): number
}
type TA2 = {
  fnA(a: 3 | 4): 20
  fnB(): string
}

type TB1 = TA1 & TA2
type TB2 = TA2 & TA1

function test(tb1: TB1, tb2: TB2) {
  // 根据参数判断重载返回不同的类型
  const a1 = tb1.fnA(1) // 10
  //    ^?
  const a2 = tb2.fnA(3) // 20
  //    ^?

  // 无法判断是哪个重载
  const b1 = tb1.fnB()
  //    ^?
  const b2 = tb2.fnB()
  //    ^?
}
```
[TS Playground](https://www.typescriptlang.org/play?#code/LAKALgngDgpgBAFQIIEY4F44G9RzgMwDskAKAQwC440AfOAJgEoqUAGXAwgIRObkICuAWwBGMAE6gAvqEixESehmwcipSnADMcOgBY+9diDxEefAM5hxAS0IBzaaFnR4CLmkzI0AMgX1n8m5Knopwvl5OIPgChADGYNYA9oRwYDCWJGAiKFRuKAA0qSL0uVxMKsZwAPRVcICcFoB2xoBDyoAOpoAkSoC1poCziYC+8YAr8YB7aoCwcoAwKoAhboDePoDR6hyxyZZwZB5FKAB0aiQojNW1bBw1eHgAegD8s-Ngi8FF9OvEJJrbB4b7tYenkXgHgAemgKs2nYB6M0AVyqAKjleudCAtssosmtTLxXoc4B9KnNIZdijDinczIj3mcQFIgA)。Type 的 & 生成的函数重载并不会报错，甚至这个函数重载失效也不报错（`TB1.fnB` 和 `TB2.fnB`）。对于 & 函数 `fnB` 生成的两个重载和 & 顺序有关，代码是可以正常使用的，不过签名却只能使用第一个重载签名，`fnB` 是无参数的无法判断是哪个重载。 `b1` 是 `number` 类型，`b2` 是 `string` 类型。

  </td>
</tr>
</table>

## type 模拟 class 抽象类
---

<table>
<tr>
  <td width="50%">
interface 是一种类型约束。当我们实现一个 interface 的时候，要么把所有成员全部实现了，要么把未实现的成员标记成抽象的。也就是需要这样一个约束，我只实现部分 interface 的成员，剩下的成员可以交给外部实现。虽然这是抽象类的功能，但 type 也是可以达到这种约束的。

```ts
interface IA {
  a: number
  fn1(): number
}

abstract class CA implements IA {
  a = 3
  abstract fn1(): number
}

class CA2 extends CA {
  fn1() {
    return this.a + 10
  }
}
```
[TS Playground](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgJIEFkG8CwAoZZOALmRAFcBbAI2n0JhAEYAKASlIprrwF998cagGcwURGGQIANnGHDkAYUzBKAB2kRKEcAozZ6RZAF5kAZkNDR4hJMasOZKrSj5+efDLkLlAJmQQAB6QIAAmPpi4BMj27AbRhFAQYORQIMhgABbAwgB0cMgA1MhMAAyG7rxAA)

  </td>
  <td width="50%">

Ts 的 type 做这种约束很简单，一个内置类型（`Omit<T, K> 或 Pick<T, K>`）和对象展开（`...obj`）就可以做到了。[TS Playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBAKgglAvFA3gWAFBSgQwFxQB2ArgLYBGEATptgGaECMAFAJQEkXWYC+mokWHEZIoAeVIBLYAB54AGigAiBoyUA+TJgDGAe0IBnYFDA4qwSTgA2ASVJgrjAvBHJ0WXAQDMvLRj2GxpL2js4IbrRQAHQxpuaWtiGMkQD0KVCAedqADc6AlkqA0HKAIW6AFwmAYEqACEaAGiq+GDr6RlDBDgBMYaLu2DFRcRbWdg6M8pGqBGxI6g0hTVE4UADUUIwADIMeaVCAyvpCUIB5GoAFSoAAcoBUcpVQDE1QgG+mgDD-qekuUICwcoBY8oClRoCYqVeAm-GAM4mA9GavbwKN1W6UAffGABiVAGFygG8fQDR6oABi0Ap+ZXQBlfoB9cy2BUAxtaAOw9stUgA)。
``` ts
type TA = {
  a: number
  fn1(): number
}
type TA1 = Omit<TA, "fn1">

const partialImpl1: TA1 = {
  a: 3
}

const impl1: TA = {
  ...partialImpl1
  // 实现剩下的部分成员
}

const impl2: TA = {
  ...partialImpl1,
  fn1: () => impl2.a + 10,
  // 当 TA 增加一个成员 fn2 时，
  // TA1 不会报错，这里是会报错的，
  // 达到了类型检查，约束 TA 的正确实现
}
```
  </td>
</tr>
</table>
