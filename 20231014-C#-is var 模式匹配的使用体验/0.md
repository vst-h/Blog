<!-- # C# - is var 模式匹配的使用体验 -->
## is 模式匹配
模式匹配在 C# 8 迎来陆续的更新支持，微软比较全面的介绍文档：
[pattern](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns)。
这篇文章会把一些有意思的用法提出来交流一下。

留意一下这个代码：
``` c#
int Test(DayOfWeek x) => x switch {
    DayOfWeek.Saturday | DayOfWeek.Sunday  => 100,
    _ => 10,
};
```
发现问题了吗，`|` 是位运算符，会把 `|` 运算结果作为匹配值。上面的代码没有任何报错和警告，
模式匹配使用 `or`, `and`, `not` 这些关键字作为逻辑运算。

## 不同于 `==` 运算符，`is` 的妙用

`==` 是二元运算符，如果要判断一个值 `x` 是否属于几个枚举类型，用 `==` 运算符是这样的：
``` cs
if (x == Type.Add || x == Type.Update || x == Type.Replace) { }
```
或者判断 `x` 是否是几个状态值：
``` cs
if (new[] {3, 4, 6, 9}.Contains(x)) { }
```

---

现在 is 模式匹配就可以优雅的表达：
``` cs
if (x is Type.Add or Type.Update or Type.Replace) { }

if (x is 3 or 4 or 6 or 9) { }
```


## `is` 辨别非 `null` 值

`x is {}`，`{}` 大括号内可以写是对象属性的匹配，例如匹配一个 DateTime：` date is { Year: 2023, Month: 10 }`。`{}` 就是一个非空的匹配了，第一次见这个表达式还以为是 x 必须是一个对象（非基本类型，和 js 搞混了）。
```cs
void Test(DateTime? date) {
    var isNotNull = date is {};
}
```

## 对 `null` 值更好的处理
审查一下这个代码，`isNoData ` 是否符合代码逻辑，表示一个没有数据的状态：
``` cs
void Test1(IEnumerable<int>? list) {
    var isNoData = list?.Count() == 0;
    // ...
}
```
需要一个辨别是无数据的状态，注意 `?.` 的使用就会发现代码遗漏处理 `null` 值的情况。如果要代码简洁的写，可以这样：`!(list?.Count() > 0)`，意思是 `!hasData`，整个表达式看上去就像绕了两层。在模式匹配之前，如果不使用 `!` 取反，那么需要两个逻辑运算：
``` cs
void Test2(IEnumerable<int>? list) {
    var isNoData1 = list == null || list.Count() == 0;
    var isNoData2 = list?.Count() is null or 0; // 使用 is 模式匹配后
}
```



## `is var` 声明一个变量

看一个获取文件后缀名的代码示例：
``` cs
string? GetExtension(string name) {
    var i = name.LastIndexOf('.');
    return i >= 0 ? name.Substring(i) : null;
}
```
使用 `is var` 试试，代码流畅很多，变量 `i` “看起来”的使用范围变得更小了：
``` cs
string? GetExtension(string name)
    => name.LastIndexOf('.') is var i and >= 0 ? name.Substring(i) : null;
```

---

还有其他有用的示例，简洁快速的拿到 list1 并处理数据：
``` cs
Task<List<int>> GetList() => Task.FromResult(new List<int>());

async void Test() {
    if (await GetList() is var list1 and { Count: > 0 }) {
        // do something
    }
}
```

## `is var` 模式匹配的细节

从这几个代码示例来看， **`is var` 模式似乎总是匹配成功的**，然而会有某些情况不是总是匹配成功的（之后讨论）。

`is var` 声明的变量也不一定是只在 `true` 分支内的，其他分支也可以访问，示例：
``` cs
void Test1(int num) {
    if (num is var x && x > 100) { // 注意这里使用的是 &&
        x.ToString(); // 正常使用变量
    }
    x.ToString(); // 正常使用变量
}
```
这个示例的 `is var` 模式总是匹配成功的，看编译后
（[sharplab.io](https://sharplab.io/#v2:CYLg1APgAgTABAYQIIG8CwAoO25QCxwAqApgM4AuAjABQCWAduXPQK4C2AlHOljn7QDM41Vmzi1ScAG4BDAE5wAHnABkKpXAB8cSgAZdXFHAD0xuIAubQPCGgTfjAM4mB/eUAUroBC3QPRmqlZj7ecigHSEAPYAyuRyDADm1BwA3CZmgMbWgBx6ToAbyoDziV4+cAC+WT7+QaHh9FGx8XDJaZm82HkY9UA==)）
的代码：

``` cs
void Test1(int num) {
    int num2 = num;
    if (num2 > 100) {
        num2.ToString();
    }
    num2.ToString();
}
```
`num2` 在整个方法内都可访问，if 内的 `is` 判断也优化掉了。


---

上面的代码稍作修改，`x` 就不能正常在其他分支使用，报错：使用了未赋值的变量。
``` cs
void Test2(int num) {
    if (num > 100 && num is var x) {
        x.ToString(); // 正常使用变量
    }
    x.ToString();// error: Use of unassigned local variable 'x'
}
```
重新赋值就可以使用了，而且 if 之后的不能再声明同名的变量 `x` ，因为 `is var` 已经声明了。

日常写代码好几次用了同名的 `is var` 声明变量而报错：
``` cs
void Test2(int num1, int num2) {
    if (num1 > 100 && num1 is var x) {
        x.ToString(); // 正常使用变量
    }
    if (num2 > 100 && num2 is var x) {
        //                        ^
        // error: 'x' is already defined in this scope
    }
}
```

## `is var` 元组解构

``` cs
void Test1(int? x, (int, int)? tup) {
    if (x is var x2) {
        Console.WriteLine("x2: " + x2);
    }
    if (tup is var (a, b)) {
        Console.WriteLine($"a: " + a);
    }
}
```
调用 `Test(null, null)` 代码会输出什么？

停一下，再看答案。答案是：只会输出一行 `"x2: "`，也就是第二个 `is var` 没有匹配成功，这种处理真不错，很符合直觉。
匹配没有成功是因为包含了解构元组的操作，如果不解构，`is var` 还是总会匹配成功的。
``` cs
void Test1((int, int)? tup) {
    if (tup is var tup2) {
        _ = tup2.HasValue; // tup2 是 Nullable<T> 类型，可能为 null
    }
}
```

## “类的解构”模式匹配也会处理吗
一个类也可以实现解构操作啊（文档：
[deconstruct](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct#user-defined-types)
），模式匹配会处理吗？

情况比想象的复杂，不能一概而论。

### object 元组解构模式匹配：
<table>
<tr>
  <td width="50%">

``` cs
void Test1(object obj) {
    if (obj is var (a, _)) {
        Console.WriteLine(a);
    }
}
```
看右边的反编译代码就明白。`ITuple` 是程序集内部的接口（`internal` 声明），元组类型都实现了。所以 `object 类型`的**元组解构**模式匹配只处理元组类型。
  </td>
  <td>

``` cs
void Test1(object obj) { // 反编译的代码
    ITuple tuple = obj as ITuple;
    if (tuple != null && tuple.Length == 2) {
        object value = tuple[0];
        Console.WriteLine(value);
    }
}


```
  </td>
</tr>
</table>

### 确定类型进行元组解构模式匹配：

<table>
<tr>
  <td width="50%">

写一个实现解构函数的类 `CA`，测试后惊喜的发现居然支持元组解构模式匹配。
不过示例的代码是对确定的类型进行元组解构模式匹配，没有发生类型转换（`as` 转换）。
``` cs
void Test2(CA? obj) {
    if (obj is var (a, _)) {
        Console.WriteLine(a);
    }
}
class CA {
    int X = 0; int Y = 0;
    public void Deconstruct(out int x, out int y)
        => (x, y) = (X, Y);
}
```
  </td>
  <td>

``` cs
// 反编译的代码
void Test2(CA obj) {
    int y;
    if (obj != null) {
        int x;
        obj.Deconstruct(out x, out y);
        Console.WriteLine(x);
    }
}


```
  </td>
</tr>
</table>

---

<table>
<tr>
  <td width="50%">
如果是一个可解构的结构体，还是可空类型呢？上代码：

``` cs
void Test3(SA? obj) {
    if (obj is var (a, _)) {
        Console.WriteLine(a);
    }
}
record struct SA(int X, int Y);
```
看右边反编译的结果，显然代码会和预期那样正确的支持这种匹配操作的。

  </td>
  <td>

``` cs
void Test3(Nullable<SA> obj) {
    if (obj.HasValue) {
        int X;
        int Y;
        obj.GetValueOrDefault().Deconstruct(out X, out Y);
        Console.WriteLine(X);
    }
}
```

  </td>
</tr>
</table>

等等，发现了一个问题，object 解构可空的元组会不会失败，因为 `Nullable<(int ,int)>` 类型是没有实现 `ITuple` 的。

---

<table>
<tr>
  <td width="50%">

灵光一闪，应该是不会的，因为 `Nullable<T>` 是 CLR 特殊处理的类型。拿之前的代码 `Test1` 来看：
``` cs
void Test1(object obj) {
    if (obj is var (a, _)) {
        Console.WriteLine(a);
    }
}
```
  </td>
  <td>

``` cs
void Test1(object obj) { // 反编译的代码
    ITuple tuple = obj as ITuple;
    if (tuple != null && tuple.Length == 2) {
        object value = tuple[0];
        Console.WriteLine(value);
    }
}
```
  </td>
</tr>
</table>

`Nullable<T>` 是特殊处理的，看下面的代码测试：
``` cs
int? x = null;
_ = x.HasValue; // x 不会抛空引用异常
// x.GetType(); // 这里是会抛出空引用异常的，
// 不给运行时获取 “null” 值的类型，虽然实际上它就是 `Nullable<T>` 结构体
Console.WriteLine(x is IComparable<int>); // false

x = 1;
Console.WriteLine(x is IComparable<int>); // true
// 对 Nullable<int> 的类型测试，表明它确实是 IComparable<int> 类型
// 但你要直接写 x.CompareTo(233); 编译器会在编译期报错打你脸
// 需要这么写 x.Value.CompareTo(233);
Console.WriteLine(x.GetType()); // System.Int32
```
`ITuple` 是程序集内部接口，我们测不了。上面的测试也表明：**对 `Nullable<T>` 的类型测试要么是 `null` 未知类型，要么就是 `T` 类型**。

当一个 `Nullable<(int, int)>` 类型有值的时候，代码 `ITuple tuple = obj as ITuple;` 的 `tuple` 自然也就有值。


---

<table>
<tr>
  <td width="50%">

查找其他文档发现解构模式匹配可以指定类型。
这样 obj 的元组解构就不仅仅是元组类型了，只要支持了解构的类就可以使用。
``` cs
void Test1(object obj) {
    if (obj is var (a, _)) {
        Console.WriteLine(a);
    }
    if (obj is SA(var a2, _)) {
        Console.WriteLine(a2);
    }
}
record struct SA(int X, int Y);
```

  </td>
  <td>

``` cs
void Test1(object obj) { // 反编译代码
    ITuple tuple = obj as ITuple;
    if (tuple != null && tuple.Length == 2) {
        object value = tuple[0];
        Console.WriteLine(value);
    }
    if (obj is SA) {
        int X;
        int Y;
        ((SA)obj).Deconstruct(out X, out Y);
        Console.WriteLine(X);
    }
}
```
  </td>
</tr>
</table>

---

（这几个元组解构测试代码的反编译在线示例：
[sharplab.io](https://sharplab.io/#v2:D4AQTAjAsAUL4AIDCAVApgZwC4IN6wUIRAGZiIA2YgFgXWwgAoB7AIwCs0BjHN9gSjwEiIgJYAzBCw4JRGBADcAhgCcpSgDQIA+v0H4YIo0RAQAnIyX8A3MOMBfO0YlS+s+QGUAgo2VqlYFq6+k7GhKYWATahRI6GsU6mVCC09FhgjEheAPwIfCHxxi7S7O6KqupBekKFYeHmltG1InEtiZQ0dJhYJIzeufk1dcVucuVqllUFdSIRjbbNCbWtJh0pXdjUjIyiAHZYWntY/AMc02EjMmN+lQis1QYzq5EIANR3TXUrhHFx8GDILxDIhHBAADQQAF4EAAGayyfYIACaUNhC1mZHWABFuMxdtgVABXHgsQk4UEADy0zDJCJwAE9BJCAHxSKkIRmoxhgrRIpp/GAqXEqAAmCAJxJw3h2iJ5dORTVgQA=)
）

## `is var xxx and` 声明的变量不能在其他分支使用
参考下面的代码，`is var xxx &&` 声明的变量是可以在其他分支可使用的。

``` cs
public Task<List<int>> GetListA() => Task.FromResult(new List<int>());

public Task<(int, int, int)> GetTupleA() => Task.FromResult((1, 2, 3));

public async Task Test() {
    if (await GetListA() is var list1 && list1.Count == 0 && list1 is []) {
        throw new Exception();
    }
    _ = list1; // can use

    if (await GetListA() is var list2 and { Count: 0 } and []) {
        throw new Exception();
    }
    _ = list2; // error: Use of unassigned local variable 'list2'

    // There are other types of uses

    if (await GetTupleA() is var (a1, b1, c1) and (>10, >100, >1000)) {
        throw new Exception();
    }
    _ = (a1, b1, c1); // error

    if (await GetTupleA() is var (a2, b2, c2) && a2 >10 &&  b2 >100 && c2 >1000) {
        throw new Exception();
    }
    _ = (a2, b2, c2); // can use
}

```
目前 `and` 匹配模式没有像 `&&` 逻辑运算符那样得到支持，使其变量在其他分支使用。
具体会不会支持，不知道。

有一种考虑是 `&&` 逻辑运算符是短路径求值的，
可是 `and` 匹配也是编译期的匹配啊，`and` 匹配会有什么副作用？

有一种情况就是 `is var` 并不一定总是匹配成功，例子就是对可空元组解构匹配。
例如 `is var (a, b) &&` 目前也能检测出来使用了未赋值的变量，而且还是编译期报错，
`and` 匹配照样处理就行了。但目前来看就是没有得到支持。

``` cs
void Test((int, int)? obj) {
    if (obj is var (a, b)) {
        Console.WriteLine(a + b);
    }
    _ = a + b; // error: Use of unassigned local variable
}
```
