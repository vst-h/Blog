## 问题
@1 处的 `b` 调用 `FnA` 之后无法调用 `FnB`，如果要实现调用，应该如何实现？
``` cs
void Test1(CB b) {
    b.FnB().FnA();
    b.FnA().FnB(); // @1
}

class CA {
    public CA FnA() => this;
}

class CB : CA {
    public CB FnB() => this;
}
```
一种解决方式，泛型 + 扩展方法：
``` cs
class CA { }

class CB : CA {
    public CB FnB() => this;
}

static class CAEx {
    public static T FnA<T>(this T self) where T : CA
    => self;
}
```

## 问题2：如果 `CA` 是一个泛型呢

``` cs
void Test1(CB<int> b) {
    b.FnB().FnA(); // error
    b.FnA().FnB(); // error
}

class CA<T> { }

class CB<T> : CA<T> {
    public CB<T> FnB() => this;
}

static class CAEx {
    public static TC FnA<TC, A>(this TC self) where TC : CA<A>
    => self;
}
```
在线代码 [sharplab.io](https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwLACgACAWABAFQFMBnYARgAoBhAIQB4BLKYAPlwCMBKXAbw1wEcAdADEoNCp1FQAgpIDcuAPRLchMGAD2YfoPbS5UsRM6KVajdowBfDBkwAmXFRl18bHrlvp7T2m7YQZ1d3Xl0BTABmZ3pQ40lcAF42YAALBmJ5GzssMgA2XEdggFEADzD0QULozHyCKlwxEKoYXBkWCjSM+txiQgAbADNuAHdU9UIeoJc6dvCktj6hrPRrIA=)。上面的代码调用 `FnA` 就报错了：
```
The type arguments for method 'CAEx.FnA<TC, A>(TC)' cannot be inferred from the usage. Try specifying the type arguments explicitly
```
按照报错修改，那就需要特别指定 `FnA` 的泛型参数：`FnA<CB<int>, int>()`。这也太难看了吧，难写难看，不具备可使用性。

----

查看具体泛型推导情况，是 `FnA<TC, A>` 中的 `A` 没有根据 `TC` 推导出 `int` 类型。
![](img\q2.png)
> 试了一下 TS，它也推导没出来，[playground](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMIEEA8AVAfMgb2TgC5ltkBfAKFElkRVQCEd8IAPSEAEwGc0WPIWQAjMhRowAriARhgAexDJIfMAEYcyTt36DM6XABpkRgBRgJASjLoRYABZRFAd2QAiD1WrUZchWVVCHUAJnNxNFZ1KFAAc1xrQmpkZARldWQOZABeYPUNCOsU5AB6UtTUgD0AfmpKIA)
> ![](img\q21.png)

## 探索

再次提一遍我要处理的问题，我是希望**基类**有一些公共的 `FnA` 函数给后继的**继承类**使用，并且不要把后继的**继承类**的类型搞丢，以实现 `b.FnA().FnB()` 这样的调用。
``` cs
void Test1(CB b) {
    b.FnB().FnA();
    b.FnA().FnB();
}

class CA {
    public CA FnA() => this;
}

class CB : CA {
    public CB FnB() => this;
}
```
目前明确一点，直接使用扩展方法 `(this T) where T: ...` 这种是不可能推导出 `T` 里面的泛型参数的，也不知道语言后面会不会支持。

继承也是不可能实现的（TS 可以，`FnA(): this`）。

可能达到操作的是在扩展方法，冥思苦想几天，偶然灵光一闪冒出一个思路。一个类型带有它自己的继承类类型进来：`class CA<T, A>; `, `class CB<T> : CA<T, CB<T>>>`。是不是可以了？

那么我这个扩展方法是什么呢，返回继承类，扩展 `CA<T, A>`。函数签名就有了（在线代码 [sharplab.io](https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AFgAIAVAUwGdhMAKAYQCEAeASymAD5iAjASmIBvPMVG8AdADEojWnylQAgnIDcIsTwXL502XzW4AvngKYAbMQzF6igKIAPIetGoAzJfPFFxaYuakYL05aYAALVkprPwCg4kpyABsAMwEAd1DyMHIvECj/QMVOZ2IAXm545OIAQ0jvAH464jCwAHtU4ihydoBJKAA3KoTWOAB5AAdMquBWFqgHAGNyMenZ1TxjfFwrG3zYwWINgnRrFlJuXJ2Ypn9ObmFcMUt3a7OfGTlS7jCIg0MgA===)）：
``` cs
void Test1(CB<int> b) {
    b.FnB().FnA();
    b.FnA().FnB();
}

static class CAEx {
    public static A FnA<T, A>(this CA<T, A> self) where A: CA<T, A>
    => self as A ?? throw new InvalidOperationException();
}

class CA<T, A> { }

class CB<T> : CA<T, CB<T>> {
    public CB<T> FnB() => this;
}
```
好了，到目前为止，问题已经可以解决了。

> 题外延展：后面的继承类呢？
> ``` cs
> class CB2: CB<int> {
>    public CB2 FnB2() => this;
> }
> void Test1(CB2 b) {
>    b.FnB2().FnA();
>    b.FnA().FnB2(); // 报错
> }
> ```
>  `CB2` 调用 `FnA` 方法返回值将是 `CB<int>`，会丢失掉最初的类型。

<!-- ## 问题3：后继的继承类呢

``` cs
void Test1(CB2 b) {
    b.FnB2().FnA();
    b.FnA().FnB2(); // 报错
}

static class CAEx {
    public static A FnA<T, A>(this CA<T, A> self) where A: CA<T, A>
    => self as A ?? throw new InvalidOperationException();
}

class CA<T, A> { }
class CB<T> : CA<T, CB<T>> { }
class CB2: CB<int> {
    public CB2 FnB2() => this;
}
```
> 报错：`CB<int>` 没有 `FnA` 方法

这里的继承关系 `CB2` -> `CB<int>` -> `CA<int, CB<int>>`，调用了 `FnA` 之后返回的是 `CB<int>`，
已经丢失了最开始的类：`CB2`。

`CA` 的扩展方法是这样的：`FnA<T, A>(this CA<T, A> self)`，它要求所有 -->

## 问题3：`CA` 并没有完全的抽象

