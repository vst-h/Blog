## 问题
@1 处的 `b` 调用 `FnA` 之后无法调用 `FnB`，如果要实现调用，应该如何实现？
``` cs
void Test1(CB b) {
    b.FnB().FnA();
    b.FnA().FnB(); // @1
}

class CA {
    public CA FnA() => this;
}

class CB : CA {
    public CB FnB() => this;
}
```
一种解决方式，泛型 + 扩展方法：
``` cs
class CA { }

class CB : CA {
    public CB FnB() => this;
}

static class CAEx {
    public static T FnA<T>(this T self) where T : CA
    => self;
}
```

## 问题2：如果 `CA` 是一个泛型呢

``` cs
void Test1(CB<int> b) {
    b.FnB().FnA(); // error
    b.FnA().FnB(); // error
}

class CA<T> { }

class CB<T> : CA<T> {
    public CB<T> FnB() => this;
}

static class CAEx {
    public static TC FnA<TC, A>(this TC self) where TC : CA<A>
    => self;
}
```
在线代码 [sharplab.io](https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwLACgACAWABAFQFMBnYARgAoBhAIQB4BLKYAPlwCMBKXAbw1wEcAdADEoNCp1FQAgpIDcuAPRLchMGAD2YfoPbS5UsRM6KVajdowBfDBkwAmXFRl18bHrlvp7T2m7YQZ1d3Xl0BTABmZ3pQ40lcAF42YAALBmJ5GzssMgA2XEdggFEADzD0QULozHyCKlwxEKoYXBkWCjSM+txiQgAbADNuAHdU9UIeoJc6dvCktj6hrPRrIA=)。上面的代码调用 `FnA` 就报错了：
```
The type arguments for method 'CAEx.FnA<TC, A>(TC)' cannot be inferred from the usage. Try specifying the type arguments explicitly
```
按照报错修改，那就需要特别指定 `FnA` 的泛型参数：`FnA<CB<int>, int>()`。这也太难看了吧，难写难看，不具备可使用性。

----

查看具体泛型推导情况，是 `FnA<TC, A>` 中的 `A` 没有根据 `TC` 推导出 `int` 类型。
![](img\q2.png)
> 试了一下 TS，它也推导没出来，[playground](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMIEEA8AVAfMgb2TgC5ltkBfAKFElkRVQCEd8IAPSEAEwGc0WPIWQAjMhRowAriARhgAexDJIfMAEYcyTt36DM6XABpkRgBRgJASjLoRYABZRFAd2QAiD1WrUZchWVVCHUAJnNxNFZ1KFAAc1xrQmpkZARldWQOZABeYPUNCOsU5AB6UtTUgD0AfmpKIA)
> ![](img\q21.png)

## 探索

再次提一遍我要处理的问题，我是希望**基类**有一些公共的 `FnA` 函数给后继的**继承类**使用，并且不要把后继的**继承类**的类型搞丢，以实现 `b.FnA().FnB()` 这样的调用。
``` cs
void Test1(CB b) {
    b.FnB().FnA();
    b.FnA().FnB();
}

class CA {
    public CA FnA() => this;
}

class CB : CA {
    public CB FnB() => this;
}
```
目前明确一点，直接使用扩展方法 `(this T) where T: ...` 这种是不可能推导出 `T` 里面的泛型参数的，也不知道语言后面会不会支持。

继承也是不可能实现的（TS 可以，`FnA(): this`）。

可能达到操作的是在扩展方法，冥思苦想几天，偶然灵光一闪冒出一个思路。一个类型带有它自己的继承类类型进来：`class CA<T, A>; `, `class CB<T> : CA<T, CB<T>>>`。是不是可以了？

那么我这个扩展方法是什么呢，返回继承类，扩展 `CA<T, A>`。函数签名就有了（在线代码 [sharplab.io](https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUH1AFgAIAVAUwGdhMAKAYQCEAeASymAD5iAjASmIBvPMVG8AdADEojWnylQAgnIDcIsTwXL502XzW4AvngKYAbMQzF6igKIAPIetGoAzJfPFFxaYuakYL05aYAALVkprPwCg4kpyABsAMwEAd1DyMHIvECj/QMVOZ2IAXm545OIAQ0jvAH464jCwAHtU4ihydoBJKAA3KoTWOAB5AAdMquBWFqgHAGNyMenZ1TxjfFwrG3zYwWINgnRrFlJuXJ2Ypn9ObmFcMUt3a7OfGTlS7jCIg0MgA===)）：
``` cs
void Test1(CB<int> b) {
    b.FnB().FnA();
    b.FnA().FnB();
}

static class CAEx {
    public static A FnA<T, A>(this CA<T, A> self) where A: CA<T, A>
    => self as A ?? throw new InvalidOperationException();
}

class CA<T, A> { }

class CB<T> : CA<T, CB<T>> {
    public CB<T> FnB() => this;
}
```
好了，到目前为止，问题已经可以解决了。

> 题外延展：后面的继承类呢？
> ``` cs
> class CB2: CB<int> {
>    public CB2 FnB2() => this;
> }
> void Test1(CB2 b) {
>    b.FnB2().FnA();
>    b.FnA().FnB2(); // 报错
> }
> ```
>  `CB2` 调用 `FnA` 方法返回值将是 `CB<int>`，会丢失掉最初的类型。

<!-- ## 问题3：后继的继承类呢

``` cs
void Test1(CB2 b) {
    b.FnB2().FnA();
    b.FnA().FnB2(); // 报错
}

static class CAEx {
    public static A FnA<T, A>(this CA<T, A> self) where A: CA<T, A>
    => self as A ?? throw new InvalidOperationException();
}

class CA<T, A> { }
class CB<T> : CA<T, CB<T>> { }
class CB2: CB<int> {
    public CB2 FnB2() => this;
}
```
> 报错：`CB<int>` 没有 `FnA` 方法

这里的继承关系 `CB2` -> `CB<int>` -> `CA<int, CB<int>>`，调用了 `FnA` 之后返回的是 `CB<int>`，
已经丢失了最开始的类：`CB2`。

`CA` 的扩展方法是这样的：`FnA<T, A>(this CA<T, A> self)`，它要求所有 -->

## 问题3：`CA` 并没有完全的抽象

现在 `FnA` 方法要约束有一个 `IA` 接口，

``` cs
static class CAEx {
    public static A FnA<A>(this CA<IA, A> self) where A: CA<IA, A>
    => self as A ?? throw new InvalidOperationException();
}

class CA<T, A> { }
class CB<T> : CA<T, CB<T>> {
    public CB<T> FnB() => this;
}

interface IA { }
interface IB: IA { } // 留意这个接口
```

调用还是可以正常的，没报错（在线代码 [sharplab.io](https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAICYCMBYAUHgegIBUBTAZ2EwAopSB3AAmoEoWBuPPVAFkbMo0AwgCEAPAEkAggD5GAIxaMA3nkbqFAOgBiUEax1QprTrg1bdxlof0c8AXy65UmAGyMMjIVICiADxU1DVQAZg83RilGSzFZamAACwBLci8pSSkYSLlyUgAbADMlegTSMFJIkDSMrNkg9QBeHPyCxgBDVKiAfi7GRLAAeyY6JgkoADc2vKS4AHkABzK24CSBqH8AY1J5lbWTBydPbzFiWrllRkd8Z3QvcWI5KuPTu5OZc/qPMNE36L1WRhNPrJcimK54JJQYBlAptLaMaQqS4QqEwuEVCQiKqIi72RhAA==)）：
``` cs
static void Test1(CB<IA> cb) {
    cb.FnB().FnA();
    cb.FnA().FnB();
}
```
假如 `CB<IA>` 扩展一下变成 `CB<IB>`，那么就会报错了。虽然 `IB` 继承接口 `IA`，但是 `CB<IB>` 和 `CB<IA>` 是两个类，没有继承关系。可以在刚刚的在线代码示例种修改试试看。
> 报错： `'CB<IB>' does not contain a definition for 'FnA' and the best extension method overload 'CAEx.FnA<CB<IB>>(CA<IA, CB<IB>>)' requires a receiver of type 'CA<IA, CB<IB>>'`

---
这是一个类型协变很典型的情况，举一个经典例子（在线代码 [sharplab.io](https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAIAYAEqCMAWAbgFgAoU1PTAFQFMBnYAGQEsGcAKFhgHl3QD5MDMHRiYuwbgHsARgCsaAY2CDZcugEpMAb1KZ9mAPSHMgUqNAmKmAsf4DCAQyhQpwTMwC2ABwA2zRc2CeAT0xFKSgANxowZ2AA9xpMAHIJXhwBBMxgKUTktSUVBL0DNTpMAF4hYBECTFIAXyA=)）：
``` cs
void TestList1(List<string> strs, List<object> objs) {
    // 报错：Cannot implicitly convert type 'List<string>' to 'List<object>'
    objs = strs;
}
```
具体为什么会这样，这里就不展开了（个人觉得应该得花一些篇幅去讲协变和逆变）。解决的方式也简单，使用支持协变的接口（在线代码 [sharplab.io](https://sharplab.io/#v2:C4LgTgrgdgNAJiA1AHwAIAYAEqCMAWAbgFgAoU1PTAFQFMBnYAGQEsGcAKFhgHl3QD5MDMHRiYuwbgHsARgCsaAY2CDZcugEpMAb1KZ9mNXUwBeIcBEFMpAL6lylWgwkAmdgEkASjQCGcAPJQADYAnhK8OALmImJevgHBYaySakoqhvKaOnoGRqbRdFa2QA=)）：
``` cs
void TestList2(IReadOnlyList<string> strs, IReadOnlyList<object> objs) {
    objs = strs;
}
```

---
回到刚才的代码：
``` CS
static class CAEx {
    public static A FnA<A>(this CA<IA, A> self) where A: CA<IA, A>
    => self as A ?? throw new InvalidOperationException();
}

class CA<T, A> { } // 修改 CA 应该是一个接口
class CB<T> : CA<T, CB<T>> { // CB 也应该是一个接口
    public CB<T> FnB() => this;
}

interface IA { }
interface IB: IA { }
```
`CA` 和 `CB` 都应该是一个接口，那么类转为接口，类的方法直接写成扩展方法实现（扩展方法实在是太棒了）。

``` CS
static class CAEx {
    public static A FnA<A>(this CA<IA, A> self) where A: CA<IA, A>
    => self as A ?? throw new InvalidOperationException();
}

class CA<T, A> { } // 修改 CA 应该是一个接口
class CB<T> : CA<T, CB<T>> { // CB 也应该是一个接口
    public CB<T> FnB() => this;
}

interface IA { }
interface IB: IA { }
```

修改为协变接口实现（在线代码 [sharplab.io](https://sharplab.io/#v2:CYLg1APgAgTAjAWAFDOVOA2ABLLBhAQQFEAPLAb2S2pwGYdMsCsAxAOwIB4CA+ACgAuACwCWAZywBJQp0kEANEx5YxAUwA2AMwCUWAO5DVAJ1VMQUmXMW8qNALzK1WrAEMJzAPweswowHs9LDZVQMk2ADcXdRFgAHkAB2MXARE/NlIAY1V4lLS+bQBuZABfVCQRNgFjTRcsiy4/AFcBLAAVRSaW3gosUvLK6trTaQAhTk625XNpLnaLMdaeZUokGiwKlpG4HoBzVQEClX3Dvr6Nwbq5HrOBoxrLkenmcl6gA)）：
``` CS
static class CAEx {
    public static A FnA<A>(this ICA<IA, A> self) where A: ICA<IA, A>
    => self as A ?? throw new InvalidOperationException();
    //      ^^ 报错
}

interface ICA<out T, out A> { }
interface ICB<out T> : ICA<T, ICB<T>> {
    int B1 { get; set; }
}
interface IA { }
interface IB: IA { }
```
> 报错了：`The type parameter 'A' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint`

接口不能使用 `as` 转换。这里的情况已经有些不着目的了，`ICB` 这个接口是没有必要的，所有的抽象都应该只在 `ICA` 这个接口上，没有必要返回泛型 `A` 了，直接返回 `ICA`。

到这里可能有的同学已经觉得不懂我在干嘛，瞎搞。那么，不急嘛，等会给看一个实际使用示例。我觉得应该另写一篇关于“继承”抽象的局限性，因为这里在实际使用中继承会封闭掉泛型的抽象，有空再写。

修改后代码（在线代码 [sharplab.io](https://sharplab.io/#v2:CYLg1APgAgTAjAWAFDKgFgAQBUCmBnAFzgAoBJAYQEEAeUgIQBoN6A+DAYwCMBKDAb2QYhHTgDoAYgDs6xbhMmVZAbkHCu8xXKkzuKlEmEYA9EYyBgGMAUroEsjQKo6gTtNAqzaA4FUC/CYCx5QCvxgPbVmVWo2Y6FkAYf8BN+MBGHUB6M0A7t0AQt1UhChp6JlYMAhwAWwAHOAwAXhENZQTfZIC0jJyYAqLtEqQAX2RUOAA2DFgMKgBRAA9+UqgAZk72suosJiw2KRoZ4gIACwBLPAnSSmm2PBwAGwAzblL8nf2DjABDdaTJ7YwAfgf0pYAnAHsAdwxJHG/SSQAN0uexWwAA8tkcK9LgQVu9JP12DhsnCEQ0hqMoONblNsLNpJMWItVjc/Cl8RhdodjgZhKcqecrmT5vcni8Pt9fv8gSCwZDobD4Yi+sjUcKMU0WkgVpIMq8DpdkRN3gBXAjYJhqjUAfRm/AwzRlcuhiuVmwNRtl8rNOECIGYlEtQA=)）：
``` cs
void Test1(ICA<IB, IB> cb) {
    cb.FnB().FnA();
    cb.FnA().FnB();

    // 调用扩展方法后都会返回 ICA<IB, IB>，这就是目的
    ICA<IB, IB> temp1 = cb.FnA();
    ICA<IB, IB> temp2 = cb.FnB();
}

static class CAEx {
    public static ICA<T, T> FnA<T>(this ICA<IA, T> self)
    => self as ICA<T, T> ?? throw new InvalidOperationException();

    public static ICA<T, T> FnB<T>(this ICA<IB, T> self)
    => self as ICA<T, T> ?? throw new InvalidOperationException();

}

// 这个协变接口还可以优化，请看下面的应用实例
interface ICA<out T, out _T> { }

interface IA { }
interface IB: IA { }
```


## 应用示例
我有一个项目 [TableRW](https://github.com/TableRW/TableRW)，是使用表达式树生成一个委托，并且这个委托是可以给用户配置再生成的。
``` cs
var lmd1 = reader.Lambda(); // Expression<Func<DataTable, List<Entity>>>
var fn1 = lmd1.Compile(); // Func<DataTable, List<Entity>>

var lmd2 = reader.Lambda(f => f.StartRow());
var fn2 = lmd2.Compile(); // Func<DataTable, int, List<Entity>>

var lmd3 = reader.Lambda(f => f.Start());
var fn3 = lmd3.Compile(); // Func<DataTable, int, int, List<Entity>>

var lmd4 = reader.Lambda(f => f.ToDictionary(entity => entity.Id));
var fn4 = lmd4.Compile(); // Func<DataTable, Dictionary<long, Entity>>

var lmd5 = reader.Lambda(f => f.StartRow().ToDictionary(entity => entity.Id));
var fn5 = lmd5.Compile(); // Func<DataTable, int, int, Dictionary<long, Entity>>

var lmd6 = reader.Lambda(f => f.Start().ToDictionary(e => e.Id).ReturnData());
var fn6 = lmd6.Compile(); // Func<DataTable, int, int, (Dictionary<long, Entity>, object)>
```
如何实现这个 `Lambda` 方法，根据 `f` 的一串链式调用返回不同 `Expression<Func<...>>`？

其中 `DataTable` 是泛型参数，`Entity` 也是泛型参数，甚至 `List<>` 也是可以更换成 `Dictionary<,>`。效果是 `Func<...>` 的参数可以配置，不能用类型写死。

下面代码是简单的抽象接口，有想法的可以试一试：

``` cs
using System.Data;
using System.Linq.Expressions;
interface IContext<TSrc, TEntity> { }
interface IContext<TSrc, TEntity, TData>: IContext<TSrc, TEntity> { }

interface IReader<out TCtx>: IReader<TCtx, TCtx>  { }
interface IReader<out TCtx, out _C> { }

static class CTest {
    record EntityA(long Id, string Name);
    static void Test1(IReader<IContext<DataTable, EntityA>> reader) {
        var lmd5 = reader.Lambda(f => f.StartRow().ToDictionary(entity => entity.Id));
        var fn5 = lmd5.Compile(); // Func<DataTable, int, int, Dictionary<long, Entity>>
    }
    static void Test2(IReader<IContext<DataTable, EntityA, object>> reader) {
        // 带有 TData 的 IContext 可以有 ReturnData() 方法返回 TData
        var lmd6 = reader.Lambda(f => f.Start().ToDictionary(e => e.Id).ReturnData());
        var fn6 = lmd6.Compile(); // Func<DataTable, int, int, (Dictionary<long, Entity>, object)>
    }
}
```
> 麻烦的是 `IContext<TSrc, TEntity, TData>` 这个要实现 `ReturnData`，不然应该用不到协变

---

直接放实现吧，直接看就行：
``` cs
using System.Data;
using System.Linq.Expressions;

interface IContext<TSrc, TEntity> { }
interface IContext<TSrc, TEntity, TData>: IContext<TSrc, TEntity> { }
interface IReader<out TCtx>: IReader<TCtx, TCtx>  { }
interface IReader<out TCtx, out _C> { }

static class CTest {
    record EntityA(long Id, string Name);
    static void Test1(IReader<IContext<DataTable, EntityA>> reader) {
        var lmd5 = reader.Lambda(f => f.StartRow().ToDictionary(entity => entity.Id));
        var fn5 = lmd5.Compile(); // Func<DataTable, int, int, Dictionary<long, Entity>>
    }
    static void Test2(IReader<IContext<DataTable, EntityA, object>> reader) {
        // 带有 TData 的 IContext 可以有 ReturnData() 方法返回 TData
        var lmd6 = reader.Lambda(f => f.Start().ToDictionary(e => e.Id).ReturnData());
        var fn6 = lmd6.Compile(); // Func<DataTable, int, int, (Dictionary<long, Entity>, object)>
    }
}

static class ReaderEx {

    public static Expression<Func<Src, List<E>>> Lambda<C, Src, E>(
        this IReader<IContext<Src, E>, C> reader
    ) => throw new NotImplementedException();

    public static Expression<F> Lambda<C, Src, E, F>(
        this IReader<IContext<Src, E>, C> reader,
        Func<IBuildFunc<C, Func<Src, List<E>>>, IBuildFunc<C, F>> buildFn
    ) => throw new NotImplementedException();
}

interface IBuildFunc<out C, out F, out _C> { }
interface IBuildFunc<out C, out F> : IBuildFunc<C, F, C> { }

static class BuildFuncEx {

    public static IBuildFunc<C, Func<S, int, R>> StartRow<C, S, E, R>(
        this IBuildFunc<IContext<S, E>, Func<S, R>, C> b
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<S, int, int, R>> Start<C, S, E, R>(
        this IBuildFunc<IContext<S, E>, Func<S, R>, C> b
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<Src, (R, Data)>> ReturnData
    <C, Src, E, Data, R>(
        this IBuildFunc<IContext<Src, E, Data>, Func<Src, R>, C> b
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<Src, int, (R, Data)>> ReturnData
    <C, Src, E, Data, R>(
        this IBuildFunc<IContext<Src, E, Data>, Func<Src, int, R>, C> b
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<Src, int, int, (R, Data)>> ReturnData
    <C, Src, E, Data, R>(
        this IBuildFunc<IContext<Src, E, Data>, Func<Src, int, int, R>, C> b
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<Src, List<E>>> ToList<C, Src, E, R>(
        this IBuildFunc<IContext<Src, E>, Func<Src, R>, C> b
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<Src, int, List<E>>> ToList<C, Src, E, R>(
        this IBuildFunc<IContext<Src, E>, Func<Src, int, R>, C> b
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<Src, int, int, List<E>>> ToList<C, Src, E, R>(
        this IBuildFunc<IContext<Src, E>, Func<Src, int, int, R>, C> b
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<Src, Dictionary<Key, E>>> ToDictionary
    <C, Src, E, R, Key>(
        this IBuildFunc<IContext<Src, E>, Func<Src, R>, C> b,
        Expression<Func<E, Key>> key
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<Src, int, Dictionary<Key, E>>> ToDictionary
    <C, Src, E, R, Key>(
        this IBuildFunc<IContext<Src, E>, Func<Src, int, R>, C> b,
        Expression<Func<E, Key>> key
    ) => throw new NotImplementedException();

    public static IBuildFunc<C, Func<Src, int, int, Dictionary<Key, E>>> ToDictionary
    <C, Src, E, R, Key>(
        this IBuildFunc<IContext<Src, E>, Func<Src, int, int, R>, C> b,
        Expression<Func<E, Key>> key
    ) => throw new NotImplementedException();
}
```